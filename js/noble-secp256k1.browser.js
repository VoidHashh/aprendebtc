/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@noble/secp256k1@1.7.1/lib/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function t(t,e){return e.forEach((function(e){e&&"string"!=typeof e&&!Array.isArray(e)&&Object.keys(e).forEach((function(r){if("default"!==r&&!(r in t)){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}}))})),Object.freeze(t)}var e={},r=t({__proto__:null,default:e},[e]);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const n=BigInt(0),i=BigInt(1),o=BigInt(2),s=BigInt(3),a=BigInt(8),c=Object.freeze({a:n,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:i,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),f=(t,e)=>(t+e/o)/e,h={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const{n:e}=c,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-i*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,a=BigInt("0x100000000000000000000000000000000"),h=f(s*t,e),u=f(-n*t,e);let l=O(t-h*r-u*o,e),y=O(-h*n-u*s,e);const d=l>a,w=y>a;if(d&&(l=e-l),w&&(y=e-y),l>a||y>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:d,k1:l,k2neg:w,k2:y}}},u=32,l=32;function y(t){const{a:e,b:r}=c,n=O(t*t),i=O(n*t);return O(i+e*t+r)}const d=c.a===n;class w extends Error{constructor(t){super(t)}}function g(t){if(!(t instanceof m))throw new TypeError("JacobianPoint expected")}class m{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof x))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(x.ZERO)?m.ZERO:new m(t.x,t.y,i)}static toAffineBatch(t){const e=function(t,e=c.P){const r=new Array(t.length),o=Z(t.reduce(((t,i,o)=>i===n?t:(r[o]=t,O(t*i,e))),i),e);return t.reduceRight(((t,i,o)=>i===n?t:(r[o]=O(t*r[o],e),O(t*i,e))),o),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return m.toAffineBatch(t).map(m.fromAffine)}equals(t){g(t);const{x:e,y:r,z:n}=this,{x:i,y:o,z:s}=t,a=O(n*n),c=O(s*s),f=O(e*c),h=O(i*a),u=O(O(r*s)*c),l=O(O(o*n)*a);return f===h&&u===l}negate(){return new m(this.x,O(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=O(t*t),i=O(e*e),c=O(i*i),f=t+i,h=O(o*(O(f*f)-n-c)),u=O(s*n),l=O(u*u),y=O(l-o*h),d=O(u*(h-y)-a*c),w=O(o*e*r);return new m(y,d,w)}add(t){g(t);const{x:e,y:r,z:i}=this,{x:s,y:a,z:c}=t;if(s===n||a===n)return this;if(e===n||r===n)return t;const f=O(i*i),h=O(c*c),u=O(e*h),l=O(s*f),y=O(O(r*c)*h),d=O(O(a*i)*f),w=O(l-u),p=O(d-y);if(w===n)return p===n?this.double():m.ZERO;const E=O(w*w),x=O(w*E),b=O(u*E),v=O(p*p-x-o*b),S=O(p*(b-v)-y*x),A=O(i*c*w);return new m(v,S,A)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=m.ZERO;if("bigint"==typeof t&&t===n)return e;let r=$(t);if(r===i)return this;if(!d){let t=e,o=this;for(;r>n;)r&i&&(t=t.add(o)),o=o.double(),r>>=i;return t}let{k1neg:o,k1:s,k2neg:a,k2:c}=h.splitScalar(r),f=e,u=e,l=this;for(;s>n||c>n;)s&i&&(f=f.add(l)),c&i&&(u=u.add(l)),l=l.double(),s>>=i,c>>=i;return o&&(f=f.negate()),a&&(u=u.negate()),u=new m(O(u.x*h.beta),u.y,u.z),f.add(u)}precomputeWindow(t){const e=d?128/t+1:256/t+1,r=[];let n=this,i=n;for(let o=0;o<e;o++){i=n,r.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(n),r.push(i);n=i.double()}return r}wNAF(t,e){!e&&this.equals(m.BASE)&&(e=x.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&E.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=m.normalizeZ(n),E.set(e,n)));let o=m.ZERO,s=m.BASE;const a=1+(d?128/r:256/r),c=2**(r-1),f=BigInt(2**r-1),h=2**r,u=BigInt(r);for(let e=0;e<a;e++){const r=e*c;let a=Number(t&f);t>>=u,a>c&&(a-=h,t+=i);const l=r,y=r+Math.abs(a)-1,d=e%2!=0,w=a<0;0===a?s=s.add(p(d,n[l])):o=o.add(p(w,n[y]))}return{p:o,f:s}}multiply(t,e){let r,n,i=$(t);if(d){const{k1neg:t,k1:o,k2neg:s,k2:a}=h.splitScalar(i);let{p:c,f:f}=this.wNAF(o,e),{p:u,f:l}=this.wNAF(a,e);c=p(t,c),u=p(s,u),u=new m(O(u.x*h.beta),u.y,u.z),r=c.add(u),n=f.add(l)}else{const{p:t,f:o}=this.wNAF(i,e);r=t,n=o}return m.normalizeZ([r,n])[0]}toAffine(t){const{x:e,y:r,z:n}=this,o=this.equals(m.ZERO);null==t&&(t=o?a:Z(n));const s=t,c=O(s*s),f=O(c*s),h=O(e*c),u=O(r*f),l=O(n*s);if(o)return x.ZERO;if(l!==i)throw new Error("invZ was invalid");return new x(h,u)}}function p(t,e){const r=e.negate();return t?r:e}m.BASE=new m(c.Gx,c.Gy,i),m.ZERO=new m(n,i,n);const E=new WeakMap;class x{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,E.delete(this)}hasEvenY(){return this.y%o===n}static fromCompressedHex(t){const e=32===t.length,r=T(e?t:t.subarray(1));if(!W(r))throw new Error("Point is not on curve");let n=function(t){const{P:e}=c,r=BigInt(6),n=BigInt(11),i=BigInt(22),a=BigInt(23),f=BigInt(44),h=BigInt(88),u=t*t*t%e,l=u*u*t%e,y=C(l,s)*l%e,d=C(y,s)*l%e,w=C(d,o)*u%e,g=C(w,n)*w%e,m=C(g,i)*g%e,p=C(m,f)*m%e,E=C(p,h)*p%e,x=C(E,f)*m%e,b=C(x,s)*l%e,v=C(b,a)*g%e,S=C(v,r)*u%e,A=C(S,o);if(A*A%e!==t)throw new Error("Cannot find square root");return A}(y(r));const a=(n&i)===i;if(e)a&&(n=O(-n));else{!(1&~t[0])!==a&&(n=O(-n))}const f=new x(r,n);return f.assertValidity(),f}static fromUncompressedHex(t){const e=T(t.subarray(1,33)),r=T(t.subarray(33,65)),n=new x(e,r);return n.assertValidity(),n}static fromHex(t){const e=N(t),r=e.length,n=e[0];if(r===u)return this.fromCompressedHex(e);if(33===r&&(2===n||3===n))return this.fromCompressedHex(e);if(65===r&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return x.BASE.multiply(F(t))}static fromSignature(t,e,r){const{r:n,s:i}=L(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const o=V(N(t)),{n:s}=c,a=2===r||3===r?n+s:n,f=Z(a,s),h=O(-o*f,s),u=O(i*f,s),l=1&r?"03":"02",y=x.fromHex(l+H(a)),d=x.BASE.multiplyAndAddUnsafe(y,h,u);if(!d)throw new Error("Cannot recover signature: point at infinify");return d.assertValidity(),d}toRawBytes(t=!1){return z(this.toHex(t))}toHex(t=!1){const e=H(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${H(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!W(e)||!W(r))throw new Error(t);const i=O(r*r);if(O(i-y(e))!==n)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new x(this.x,O(-this.y))}double(){return m.fromAffine(this).double().toAffine()}add(t){return m.fromAffine(this).add(m.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return m.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const o=m.fromAffine(this),s=e===n||e===i||this!==x.BASE?o.multiplyUnsafe(e):o.multiply(e),a=m.fromAffine(t).multiplyUnsafe(r),c=s.add(a);return c.equals(m.ZERO)?void 0:c.toAffine()}}function b(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function v(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${I(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:T(r),left:t.subarray(e+2)}}x.BASE=new x(c.Gx,c.Gy),x.ZERO=new x(n,n);class S{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?I(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new S(P(n.slice(0,64)),P(n.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${I(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=v(t.subarray(2)),{data:n,left:i}=v(r);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${I(i)}`);return{r:e,s:n}}(e?t:z(t));return new S(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!K(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!K(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=c.n>>i;return this.s>t}normalizeS(){return this.hasHighS()?new S(this.r,O(-this.s,c.n)):this}toDERRawBytes(){return z(this.toDERHex())}toDERHex(){const t=b(k(this.s)),e=b(k(this.r)),r=t.length/2,n=e.length/2,i=k(r),o=k(n);return`30${k(n+r+4)}02${o}${e}02${i}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return z(this.toCompactHex())}toCompactHex(){return H(this.r)+H(this.s)}}function A(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}const B=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function I(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=B[t[r]];return e}const R=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function H(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(n<=t&&t<R))throw new Error("Expected number 0 <= n < 2^256");return t.toString(16).padStart(64,"0")}function U(t){const e=z(H(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function k(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function P(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function z(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[r]=o}return e}function T(t){return P(I(t))}function N(t){return t instanceof Uint8Array?Uint8Array.from(t):z(t)}function $(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&K(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function O(t,e=c.P){const r=t%e;return r>=n?r:e+r}function C(t,e){const{P:r}=c;let i=t;for(;e-- >n;)i*=i,i%=r;return i}function Z(t,e=c.P){if(t===n||e<=n)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=O(t,e),o=e,s=n,a=i;for(;r!==n;){const t=o%r,e=s-a*(o/r);o=r,r=t,s=a,a=e}if(o!==i)throw new Error("invert: does not exist");return O(s,e)}function V(t,e=!1){const r=function(t){const e=8*t.length-256,r=T(t);return e>0?r>>BigInt(e):r}(t);if(e)return r;const{n:n}=c;return r>=n?r-n:r}let _,D;class q{constructor(t,e){if(this.hashLen=t,this.qByteLen=e,"number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return Et.hmacSha256(this.k,...t)}hmacSync(...t){return D(this.k,...t)}checkSync(){if("function"!=typeof D)throw new w("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=await this.hmac(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return A(...e)}generateSync(){this.checkSync(),this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=this.hmacSync(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return A(...e)}}function K(t){return n<t&&t<c.n}function W(t){return n<t&&t<c.P}function j(t,e,r,o=!0){const{n:s}=c,a=V(t,!0);if(!K(a))return;const f=Z(a,s),h=x.BASE.multiply(a),u=O(h.x,s);if(u===n)return;const l=O(f*O(e+r*u,s),s);if(l===n)return;let y=new S(u,l),d=(h.x===y.r?0:2)|Number(h.y&i);return o&&y.hasHighS()&&(y=y.normalizeS(),d^=1),{sig:y,recovery:d}}function F(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=P(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(t.length!==l)throw new Error("Expected 32 bytes of private key");e=T(t)}if(!K(e))throw new Error("Expected private key: 0 < key < n");return e}function G(t){return t instanceof x?(t.assertValidity(),t):x.fromHex(t)}function L(t){if(t instanceof S)return t.assertValidity(),t;try{return S.fromDER(t)}catch(e){return S.fromCompact(t)}}function X(t,e=!1){return x.fromPrivateKey(t).toRawBytes(e)}function M(t,e,r,n=!1){return x.fromSignature(t,e,r).toRawBytes(n)}function Y(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?33===n||65===n:r?66===n||130===n:t instanceof x}function J(t,e,r=!1){if(Y(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!Y(e))throw new TypeError("getSharedSecret: second arg must be public key");const n=G(e);return n.assertValidity(),n.multiply(F(t)).toRawBytes(r)}function Q(t){return T(t.length>u?t.slice(0,u):t)}function tt(t){const e=Q(t),r=O(e,c.n);return et(r<n?e:r)}function et(t){return U(t)}function rt(t,e,r){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const n=N(t),i=F(e),o=[et(i),tt(n)];if(null!=r){!0===r&&(r=Et.randomBytes(u));const t=N(r);if(t.length!==u)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:A(...o),m:Q(n),d:i}}function nt(t,e){const{sig:r,recovery:n}=t,{der:i,recovered:o}=Object.assign({canonical:!0,der:!0},e),s=i?r.toDERRawBytes():r.toCompactRawBytes();return o?[s,n]:s}async function it(t,e,r={}){const{seed:n,m:i,d:o}=rt(t,e,r.extraEntropy),s=new q(32,l);let a;for(await s.reseed(n);!(a=j(await s.generate(),i,o,r.canonical));)await s.reseed();return nt(a,r)}function ot(t,e,r={}){const{seed:n,m:i,d:o}=rt(t,e,r.extraEntropy),s=new q(32,l);let a;for(s.reseedSync(n);!(a=j(s.generateSync(),i,o,r.canonical));)s.reseedSync();return nt(a,r)}const st={strict:!0};function at(t,e,r,n=st){let i;try{i=L(t),e=N(e)}catch(t){return!1}const{r:o,s:s}=i;if(n.strict&&i.hasHighS())return!1;const a=V(e);let f;try{f=G(r)}catch(t){return!1}const{n:h}=c,u=Z(s,h),l=O(a*u,h),y=O(o*u,h),d=x.BASE.multiplyAndAddUnsafe(f,l,y);if(!d)return!1;return O(d.x,h)===o}function ct(t){return O(T(t),c.n)}class ft{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=N(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const r=T(e.subarray(0,32)),n=T(e.subarray(32,64));return new ft(r,n)}assertValidity(){const{r:t,s:e}=this;if(!W(t)||!K(e))throw new Error("Invalid signature")}toHex(){return H(this.r)+H(this.s)}toRawBytes(){return z(this.toHex())}}class ht{constructor(t,e,r=Et.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=N(t);const{x:n,scalar:i}=this.getScalar(F(e));if(this.px=n,this.d=i,this.rand=N(r),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=x.fromPrivateKey(t),r=e.hasEvenY()?t:c.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return U(t^T(e))}finalizeNonce(t){const e=O(T(t),c.n);if(e===n)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:i,scalar:o}=this.getScalar(e);return{R:r,rx:i,k:o}}finalizeSig(t,e,r,n){return new ft(t.x,O(e+r*n,c.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:e,px:r,rand:n}=this,i=Et.taggedHash,o=this.initNonce(e,await i(mt.aux,n)),{R:s,rx:a,k:c}=this.finalizeNonce(await i(mt.nonce,o,r,t)),f=ct(await i(mt.challenge,a,r,t)),h=this.finalizeSig(s,c,f,e);return await yt(h,t,r)||this.error(),h}calcSync(){const{m:t,d:e,px:r,rand:n}=this,i=Et.taggedHashSync,o=this.initNonce(e,i(mt.aux,n)),{R:s,rx:a,k:c}=this.finalizeNonce(i(mt.nonce,o,r,t)),f=ct(i(mt.challenge,a,r,t)),h=this.finalizeSig(s,c,f,e);return dt(h,t,r)||this.error(),h}}function ut(t,e,r){const n=t instanceof ft,i=n?t:ft.fromHex(t);return n&&i.assertValidity(),{...i,m:N(e),P:G(r)}}function lt(t,e,r,n){const i=x.BASE.multiplyAndAddUnsafe(e,F(r),O(-n,c.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function yt(t,e,r){try{const{r:n,s:i,m:o,P:s}=ut(t,e,r),a=ct(await Et.taggedHash(mt.challenge,U(n),s.toRawX(),o));return lt(n,s,i,a)}catch(t){return!1}}function dt(t,e,r){try{const{r:n,s:i,m:o,P:s}=ut(t,e,r),a=ct(Et.taggedHashSync(mt.challenge,U(n),s.toRawX(),o));return lt(n,s,i,a)}catch(t){if(t instanceof w)throw t;return!1}}const wt={Signature:ft,getPublicKey:function(t){return x.fromPrivateKey(t).toRawX()},sign:async function(t,e,r){return new ht(t,e,r).calc()},verify:yt,signSync:function(t,e,r){return new ht(t,e,r).calcSync()},verifySync:dt};x.BASE._setWindowSize(8);const gt={node:r,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},mt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},pt={},Et={bytesToHex:I,hexToBytes:z,concatBytes:A,mod:O,invert:Z,isValidPrivateKey(t){try{return F(t),!0}catch(t){return!1}},_bigintTo32Bytes:U,_normalizePrivateKey:F,hashToPrivateKey:t=>{if((t=N(t)).length<40||t.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");return U(O(T(t),c.n-i)+i)},randomBytes:(t=32)=>{if(gt.web)return gt.web.getRandomValues(new Uint8Array(t));if(gt.node){const{randomBytes:e}=gt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>Et.hashToPrivateKey(Et.randomBytes(40)),precompute(t=8,e=x.BASE){const r=e===x.BASE?e:new x(e.x,e.y);return r._setWindowSize(t),r.multiply(s),r},sha256:async(...t)=>{if(gt.web){const e=await gt.web.subtle.digest("SHA-256",A(...t));return new Uint8Array(e)}if(gt.node){const{createHash:e}=gt.node,r=e("sha256");return t.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(gt.web){const r=await gt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=A(...e),i=await gt.web.subtle.sign("HMAC",r,n);return new Uint8Array(i)}if(gt.node){const{createHmac:r}=gt.node,n=r("sha256",t);return e.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let r=pt[t];if(void 0===r){const e=await Et.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=A(e,e),pt[t]=r}return Et.sha256(r,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof _)throw new w("sha256Sync is undefined, you need to set it");let r=pt[t];if(void 0===r){const e=_(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=A(e,e),pt[t]=r}return _(r,...e)},_JacobianPoint:m};Object.defineProperties(Et,{sha256Sync:{configurable:!1,get:()=>_,set(t){_||(_=t)}},hmacSha256Sync:{configurable:!1,get:()=>D,set(t){D||(D=t)}}});export{c as CURVE,x as Point,S as Signature,X as getPublicKey,J as getSharedSecret,M as recoverPublicKey,wt as schnorr,it as sign,ot as signSync,Et as utils,at as verify};export default null;
//# sourceMappingURL=/sm/ae2770e1650b299b24df17ab3daccf59c1f04b496c059a45af9637b1396439fb.map